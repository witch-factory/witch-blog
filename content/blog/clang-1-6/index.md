---
title: C-through - 1.6. 문자 입출력을 이용한 프로그램1
date: "2021-08-15T00:00:00Z"
description: "C언어 1.6. 문자 입출력을 이용한 프로그램1"
tags: ["C", "language"]
---
# 1. 입력받은 문자 개수 세기

문자 입출력을 이용해 만들어 볼 다음 프로그램은 문자 개수를 세는 프로그램이다.

```c
#include <stdio.h>

/* 입력에 문자가 몇 개 있는지를 세어 준다 */
main() {
    long count;

    count = 0;
    while (getchar() != EOF) {
        ++count;
    }
    printf("%ld\n", count);
}
```

기본 원리는 1.5에서 다루었던 것과 같다. EOF가 나올 때까지 문자 입력을 받으면서 몇 개나 입력받았는지 세는 것이다. 

그런데 여기서 우리가 보지 못했던 연산자가 또 하나 나왔다. 바로 `++count` 에서 나온 전위 증감 연산자이다. `++count`는 `count`의 값을 1 증가시킨 후 변수의 값을 사용한다. 이는 `count=count+1` 과 같은 기능이다. 하지만 `++count` 가 더 간결하고 빠르기 때문에 1 을 증가시킬 경우 증감 연산자를 자주 쓴다.

비슷한 방식으로 변수에서 1을 감소시키는 `--count` 가 있고 또 조금은 다른 방식으로 동작하는 `count++` `count--` 후위 증감 연산자가 있다. 이는 연산자에 관해 다룰 때 추후 더 자세히 다룰 것이다.

---

<strong>NOTE</strong>

전위 연산자 `++i` 와 후위 연산자 `i++`  중 어느 것을 쓰는 게 좋은지는 꽤 오래된 떡밥이다. 결론부터 말하자면 웬만한 부분은 모두 컴파일러에서 최적화해 주며 그런 자잘한 차이에 국한되지 않을 정도로 현대의 컴퓨터 속도는 발전하였다. 실제로 시간을 측정해 보면 컴퓨터 환경에 따라 엎치락뒤치락하는 정도의 속도이다. 따라서 일반적인 경우 그냥 취향껏 쓰면 될 것이다.

하지만 이론적으로는 전위 연산자 `++i`의 승리이다. 후위 연산자 `i++`의 경우 먼저 변수의 값을 사용한 후에 변수의 값을 1 증가시켜 준다. 가령 `arr[i++]=3` 과 같은 코드가 있다면 먼저 `arr[i]=3` 을 처리해 준 후 `i`를 1 증가시켜 주는 것이다. 하지만 `arr[++i]`의 경우 그냥 `i`를 1 증가시켜 준 후 `arr[i]` 에 대한 처리를 하면 된다. 

따라서 후위 연산자의 경우 `i`의 값을 저장할 임시 공간을 만들어야 하기 때문에 후위 연산자가 전위 연산자에 비해 이론적으로는 속도가 떨어진다.  

참고 : https://stackoverflow.com/questions/24901/is-there-a-performance-difference-between-i-and-i-in-c

---

