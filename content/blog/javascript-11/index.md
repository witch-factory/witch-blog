---
title: 모던 자바스크립트 튜토리얼 part 1.6 함수 심화학습
date: "2023-01-20T00:00:00Z"
description: "ko.javascript.info part 1-6 첫번째"
tags: ["javascript"]
---

# 1. 재귀와 스택

재귀 함수는 자기 반복적인 구조를 가진 함수를 작성할 때 아주 좋다. 예를 들어서 팩토리얼 함수를 작성할 때 재귀 함수를 사용하면 아래와 같이 작성할 수 있다.

```js
function factorial(n) {
  return n ? n * factorial(n - 1) : 1;
}
```

그럼 이런 재귀 함수는 실제 js에서 어떻게 작동하는 걸까? 실행 컨텍스트가 이용된다. 이에 관한 글은 [여기](https://www.witch.work/javascript-execution-context/)에 정리하였다.

# 2. 나머지 매개변수와 spread

나머지 매개변수를 통해 인수의 개수를 무제한으로 전달할 수 있다. 그리고 나머지 매개변수에는 그 앞의 매개변수들을 제외한 나머지 인수들이 배열 형태로 모인다.

유사 배열 객체인 arguments를 사용해도 인덱스를 사용해 인수에 접근 가능하다. 그러나 이는 배열이 아니라 유사 배열 객체고 이터러블이라 반복은 가능하지만 배열 메서드를 쓸 수 없다. 또한 인수 전체를 담아 버리므로 특정 인수들만 나머지에 담는 것이 불가능하다. 그리고 화살표 함수는 arguments를 지원하지 않는다.

## 2.1. 스프레드에 대해

스프레드 문법은 이터러블에 사용될 수 있다. 스프레드는 for..of와 같은 방식으로 내부의 이터레이터를 호출하여 요소를 수집한다. 단 특정 객체를 배열로 바꿀 땐 `Array.from`이 더 많이 쓰인다. 스프레드 문법은 내부의 이터레이터를 호출하므로 이터러블에만 사용할 수 있는데, `Array.from`은 이터러블뿐 아니라 유사 배열 객체에도 쓰일 수 있기 때문이다.

그런데 스프레드 문법을 직접 써 보면 객체에도 쓸 수 있는 것을 발견할 수 있다.

```js
let a={a:1, b:2, c:3};
let aCopy={...a};
console.log(a===aCopy);
```

이상하다..단순 객체는 이터러블이 아닌데..왜 이럴까? 이는 스프레드 프로퍼티 프로포절에 객체 리터럴에 대해서도 스프레드 문법을 사용할 수 있도록 제안되었고 이게 받아들여졌기 때문이다. 이 내용은 [다른 글](https://www.witch.work/javascript-spread-object/)에 정리하였다.

# 3. 변수의 유효범위와 클로저

JS는 함수 지향 언어이고 함수 또한 객체로 취급한다. 따라서 함수의 동적 생성이나 함수를 인수로 넘기기 등이 가능하다. 이때 함수와 외부의 상호작용에 대해 좀더 알아본다.

참고로 여기서는 let, const에 대해서만 다룬다. var에 대해서는 추후에 다룰 것이라고 한다.

## 3.1 코드 블록

코드 블록은 중괄호로 묶인 부분을 말한다. 이런 블록은 특정 작업을 수행하는 코드를 한데 묶어두는 용도로 사용되며 변수 스코프로도 사용된다.

이때 let의 경우는 블록 레벨 스코프를 사용하므로 동일한 스코프에 let으로 변수를 여러 번 선언하면 에러가 발생한다.

```js
let msg = "hello";
console.log(msg);
// Identifier 'msg' has already been declared
let msg = "hello";
```

## 3.2. 렉시컬 환경

JS에서 함수는 객체이므로 당연히 함수에서 반환될 수도 있다. 이런 걸 이용할 수도 있다. 예를 들어서 다음과 같이 활용 가능하다.

```js
function addNumber(n) {
  return function (x) {
    return x + n;
  };
}

let add3 = addNumber(3);
console.log(add3(5)); // 8
```

그런데 만약 `addNumber`를 통해 함수를 여러 개 만들었을 때 이 함수들은 서로 다른 객체일까? 만약 addNumber 내에 어떤 변수가 있었다면 이 변수는 `addNumber`가 리턴하는 함수들 내에서 어떤 값을 가질 것인가? 이런 질문에 대한 답은 렉시컬 환경이 준다.

JS에서는 실행 중인 함수, 코드 블록, 그리고 전역 스크립트는 렉시컬 환경이라 불리는 숨겨진 연관 객체를 갖는다. 즉 각 스코프는 자신이 가지고 있는 정보들을 담은 객체를 가지고 있는 것이다. 이 렉시컬 환경 객체는 환경 레코드와 외부 렉시컬 환경 참조로 구성된다.

환경 레코드는 스코프가 가지는 모든 지역 변수와 this값 등의 기타 정보를 저장한다. 변수는 이 환경 레코드의 프로퍼티이고 변수를 조작하는 것은 환경 레코드의 프로퍼티를 조작하는 것이다. 그리고 외부 렉시컬 환경 참조는 말 그대로 외부 렉시컬 환경 객체에 대한 참조를 저장한다.

### 3.2.1. 변수와 렉시컬 환경

let과 const로 저장된 변수는 스크립트가 시작될 때 엔진에 인식되고 렉시컬 환경에 올라간다. 그러나 특수한 상태인 uninitialized 상태가 되어서 let, const로 선언되기 전에는 변수에 접근할 수 없다.

예를 들어 다음과 같은 코드를 보자. 주석으로 변수의 저장과 외부 렉시컬 환경 참조를 설명하였다.

```js
/* 
전역 렉시컬 환경
외부 렉시컬 환경은 없으므로 외부 렉시컬 환경 참조는 null을 가리키고 있다
지역 변수 a와 그 값 1을 프로퍼티 a:1로 저장
*/
let a=1;
if(a===1){
  /*
  외부 렉시컬 환경 참조는 전역 렉시컬 환경을 가리킨다
  지역 변수 b와 그 값 2를 저장
  */
  let b=2;
  console.log(b);
}
```

코드가 실행되고 실행 흐름이 한 줄씩 나아가면서 렉시컬 환경은 변화한다. 예를 들어서 변수 `a`를 선언하면 렉시컬 환경에서 a는 undefined로 저장될 것이다. 그리고 실행 흐름 상에서 a에 1을 저장하면 렉시컬 환경에서 a는 1로 변화할 것이다.

다음 코드를 보고 실행 흐름에 따른 렉시컬 환경 변화를 보자.

```js
/*
스크립트 시작. 스크립트에서 선언한 변수 전체가 렉시컬 환경에 올라가고 값은 특수한 상태인 uninitialized 상태가 된다. 엔진이 변수들을 인지하긴 하지만 let으로 선언되기 전까지는 해당 변수에 접근할 수 없다
*/
let a, b;
/*
a,b가 선언되었고 아직 값 할당이 안 되었으므로 프로퍼티의 값은 undefined. 
*/
a=1;
/* a에 값이 할당되었다. 전역 렉시컬 환경에 이 값이 저장된다. */
```

하지만 `var`로 선언된 변수의 경우 스크립트의 시작 시점에 초기화되어 렉시컬 환경에 올라가고 undefined로 초기화된다. 따라서 실제로 코드를 작성할 때 `var`로 선언된 변수들은 마치 모두 스크립트의 최상단에 선언된 것과 같이 쓰일 수 있다.

```js
/* 코드에선 a의 선언 전이지만 a의 선언이 
이미 스크립트 시작 시점에 처리되어 a를 사용할 수 있다 */
a = 2;
console.log(a); // 2

var a = 1;
```

### 3.2.2. 함수와 렉시컬 환경

함수 또한 하나의 값처럼 취급되므로 렉시컬 환경에 저장되어 있다. 변수와 비슷하다.

그러나 함수 선언문으로 선언한 함수의 경우 var가 그랬던 것과 같이 렉시컬 환경의 생성과 함께 초기화된다. 따라서 아직 함수 선언문에 도달하지 못했더라도 렉시컬 환경이 만들어지는 즉시 사용할 수 있다.

```js
// foo는 함수 선언문으로 선언되었으므로 바로 사용 가능
foo();

function foo() {
    console.log("hi");
}
```

이때 함수 선언문으로 선언된 함수만 이렇게 렉시컬 환경 생성과 동시에 초기화된다. 함수 표현식으로 선언한 함수는 선언 이전에 사용할 수 없다.

또한 함수를 호출해 실행하면 새로운 렉시컬 환경이 만들어진다. 여기에는 함수의 지역변수와 외부 렉시컬 환경에 대한 참조뿐 아니라 함수 호출 시 넘겨받은 매개변수도 저장된다.

그런데 함수 내에서 어떤 변수에 접근한다고 하자. 그러면 먼저 내부 렉시컬 환경에서 그 변수를 검색한다. 외부 변수와 같은 이름의 내부 변수가 있으면 그 이름의 변수에 접근 시 내부 변수에 접근하게 되는 이유가 이것이다.

만약 내부 렉시컬 환경에서 원하는 변수를 찾지 못할 시 검색 범위를 외부 렉시컬 환경으로 확장해 가며 검색한다. 이 검색은 검색 범위가 전역 렉시컬 환경이 될 때까지 반복된다.

### 3.2.3. 함수 생성과 렉시컬 환경

위에서 본, 함수를 생성하는 함수를 조금 변경해 보자.