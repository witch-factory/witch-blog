---
title: 프론트 지식 익히기 CSS-2
date: "2023-03-30T00:00:00Z"
description: "MDN CSS 튜토리얼 - 2"
tags: ["web", "study", "front", "css"]
---

[MDN의 CSS 구성요소 파트](https://developer.mozilla.org/ko/docs/Learn/CSS/Building_blocks)를 읽고 정리하는 곳이다. CSS의 필수적인 이론들을 알아보는 파트이다.

# 1. 셀렉터

앞서 갖가지 셀렉터를 알아보았다. 이제 몇 가지 추가적인 지식을 알아보자. 셀렉터들의 기본 정의와 같은 것들은 이전 글에서 했으므로 넘어간다.

## 1.1. 범용 셀렉터

`*`를 사용하여 모든 요소를 선택할 수 있다. 이는 앞서 보았다시피 모든 요소를 선택한다. 하지만 모든 요소에 동시에 스타일링을 해야 할 일은 거의 없다. 그럼 어디 쓰일까?

가독성을 높이는 데에 쓰는 것이 하나의 예시가 될 수 있다. 만약 div의 후손 중 첫번째 자식인 요소에만 글씨를 굵게 하는 스타일링을 하고 싶다면 다음과 같이 쓸 수 있다.

```css
div :first-child {
  font-weight: bold;
}
```

하지만 이렇게 쓰면 `div:first-child` 즉 첫번째 자식인 div 태그를 선택하는 것과 혼동된다. 이때 범용 셀렉터를 사용하면 다음과 같이 쓸 수 있다.

```css
div *:first-child {
  font-weight: bold;
}
```

이렇게 하면 div의 후손 중 첫번째 자식인 요소를 선택하는 것을 더 가독성 높게 표현할 수 있다.

## 1.2. 클래스 셀렉터

특정 태그 중 특정 클래스를 가진 요소를 선택할 수 있다. 예를 들어 `div.box`와 같이 사용하면 div 태그 중 box 클래스인 요소들을 선택한다.

클래스 선택자를 붙여 씀으로써 여러 클래스를 동시에 가진 요소를 선택할 수도 있다. `.box.myclass`와 같이 쓰면 box 클래스와 myclass 클래스를 동시에 가진 요소를 선택한다. box나 myclass 둘 중 하나만 가진 요소는 선택되지 않는다.

## 1.3. 의사 클래스와 의사 요소

의사 클래스와 의사 요소 선택자를 함께 쓰는 것도 가능하다. 예를 들어서 다음 선택자를 보자.

```css
article p:first-child::first-line {
  font-size: 2em;
}
```

위 선택자는 article 태그의 첫번째 자식인 p 태그의 내용 중 첫번째 줄을 선택한다.

## 1.4. ::before와 ::after

content 속성과 함께 쓰여서, CSS를 이용해서 문서 내용을 삽입할 수 있는 유사 요소가 있다. 바로 `::before`와 `::after`이다. 이들은 각각 선택한 요소의 첫 자식, 마지막 자식으로 의사 요소를 하나씩 생성한다.

그리고 이렇게 요소를 선택한 후 content 속성을 이용해서 내용을 삽입할 수 있다. 예를 들어 다음과 같이 쓸 수 있다.

```css
.box::before {
  content: "before 텍스트";
}

.box::after {
  content: "after 텍스트";
}
```

이렇게 하면 box클래스를 가진 요소의 첫 자식, 마지막 자식으로 의사 요소가 삽입되고 그 내용으로 우리는 "before 텍스트", "after 텍스트"를 삽입했다.

기존 요소의 자식으로 삽입되는 것이므로 기존 요소의 스타일링을 따라간다. 예를 들어서 h1태그, p태그에 위를 적용하자.

```html
<p class="box">테스트 문단</p>
<h1 class="box">테스트 제목</h1>
```

그러면 같은 "before 텍스트", "after 텍스트"지만 부모의 스타일을 따라간다.

![result](./before-after.png)

이를 이용해서 중요한 내용을 표시하는 것은 권장되지 않는다. 이렇게 삽입한 텍스트는 몇몇 스크린 리더에 의해 인식되지 못하며 유지보수도 힘들기 때문이다.

일반적으로는 링크의 끝에 화살표를 삽입하는 등, 스크린 리더에 읽힐 필요는 없지만 시각적인 표시를 할 때 쓰인다. 다음은 링크 끝에 화살표를 삽입하는 예시이다.

```css
a::after {
  content: "→";
}
```

그리고 이 유사 요소는 빈 문자열을 삽입하고 임의의 스타일링을 할 때도 쓰인다. 예를 들어서 문단 앞에 네모를 그리고 싶다면, before 유사 요소를 삽입하고 content 속성을 빈 문자열로 설정하고, 임의의 스타일링을 하면 된다.

```css
.box::before {
  display: block;
  width: 100px;
  height: 100px;
  background: teal;
  content: "";
}
```

꼭 빈 문자열을 content로 설정해야 하는 것을 주의하자. 그리고 width, height의 적용을 위해서는 display를 block으로 설정해야 한다.

# 2. 계단식 및 상속

## 2.1. 규칙 충돌

CSS에서 동일한 요소에 적용될 수 있는 규칙이 2가지 이상 있으면 어떻게 될까? 이런 상황을 제어하는 규칙은 계단식(cascade)과 우선순위이다.

계단식은 우선순위가 같은 규칙들이 하나의 요소에 적용될 때, CSS에서 마지막에 나오는 규칙이 적용됨을 뜻한다.

```css
// 이렇게 하면 h1 태그의 글자색은 나중에 선언된 purple이 적용된다.
h1 {
  color: red;
}

h1 {
  color: purple;
}
```

그럼 우선순위는? 기본적으로 선택자가 선택하는 요소가 얼마나 구체적인지에 따라 결정된다. 더 구체적인 선택자에 점수를 더 크게 매겨서, 큰 점수의 선택자를 적용한다. 예를 들어서 요소 선택자보다는 class 선택자가 구체적이다.

이렇게 CSS 적용 우선순위를 캐스캐이딩 순서(Cascading Order)라고 한다. 이 순서에는 3가지 규칙이 있다.

1. 중요도(Importance) 규칙 : CSS의 선언 위치에 따라 우선순위가 달라진다.
2. 명시도 : 대상을 더 구체적으로 선택하는 선택자가 우선순위가 높다.
3. 선언 순서 : 나중에 선언된 스타일이 우선적으로 적용된다.

### 2.1.1. 중요도 규칙

CSS의 선언 위치에 따른 우선순위는 다음 순서로 결정된다. 인라인 스타일이 최우선이다.

1. 인라인 스타일
2. head 요소 내의 style 요소에 정의된 스타일
3. head 요소 내의 style 요소에서 @import한 스타일
4. link 태그로 연결된 외부 스타일 시트
5. link 태그로 연결된 외부 스타일 시트에서 @import한 스타일
6. 브라우저 디폴트 스타일시트

### 2.1.2. 명시도

앞서 말했듯이 대상을 명확하게 특정한 선택자일수록 우선순위가 높다. 이를 명시도가 높다고 한다.

```
!important > 인라인 스타일 > 아이디 선택자 > 클래스/어트리뷰트/가상 선택자 > 태그 선택자 > 전체 선택자 > 상위 요소에 의해 상속된 속성
```

`!important`라는 게 있는 것을 볼 수 있다. 이는 모든 CSS 우선순위 계산을 무효화하며 특정 속성을 가장 구체적으로 만들어 일반적인 규칙을 무시한다. 하지만 정말 필요한 경우가 아니면 사용하지 않는 것이 좋디.

### 2.1.3. 선언 순서

상대적으로 나중에 선언된 스타일이 우선적으로 적용된다.

## 2.2. 상속

부모 요소에서 설정된 몇몇 CSS 속성은 자식 요소에도 상속된다. 예를 들어 color 속성을 설정한 요소가 있다면 그 자식 요소 역시 color 속성을 상속받는다. 만약 자식 요소에서 새로운 color 속성을 설정하지 않았다면 자식 요소에서도 부모 요소의 color가 나타난다.

이렇게 상속되는 속성의 여부는 CSS 속성 참조 페이지의 명세표에서 볼 수 있다. 예를 들어 [color 속성 페이지](https://developer.mozilla.org/ko/docs/Web/CSS/color#specifications)의 명세에는 다음과 같이 상속이 yes로 표시되어 있다. 

![color](./css-color.png)

상속을 제어하기 위해 사용되는 특수한 속성 값도 있다.

- inherit : 해당 속성값을 부모 요소의 속성값과 동일하게 설정한다.
- initial : 해당 속성값을 기본값으로 설정한다.
- unset : 부모로부터 상속할 속성값이 있으면 상속받고, 없으면 기본값으로 설정한다.

```css
h1{
  color:inherit;
}
```

이렇게 하면 h1 태그의 글자색은 부모 요소의 글자색과 동일하게 설정된다.

그런데 color등의 개별 요소 말고, 요소의 모든 속성의 상속을 제어하고 싶을 수 있다. 이럴 때는 all 속성을 사용한다.

```css
h1{
  all:inherit;
}
```

h1 태그의 모든 속성을 부모 요소의 속성값과 동일하게 설정하였다.

# 3. cascade layer

CSS 캐스케이드와 명시도를 기반으로 하는 고급 기능, 캐스케이드 레이어를 소개한다.

요소에 적용된 각 CSS 속성에는 하나의 값만 있을 수 있다. 배경색이 빨간색이면서 파란색일 수는 없다. 개발자 도구의 '스타일'패널엔 검사 중인 요소에 적용된 모든 속성값이 적용된 셀렉터와 함께 표시된다. 이때 가장 우선순위가 높은 셀렉터의 속성값이 적용된다.

그리고 개발자 도구에선 요소에 적용되진 않았지만 선택한 요소와 일치하는 셀렉터의 속성값들도 취소선이 그어진 채 표시된다. 이는 캐스케이드 레이어에 의해 취소된 속성값들이다.

사이트가 더 복잡해지면 스타일시트의 소스 순서가 더 복잡해질 때가 많다. 이때 캐스케이드 레이어를 사용하면 CSS 선언을 더 쉽게 관리할 수 있다.

## 3.1. 캐스케이드란

캐스케이딩은 스타일들이 어떻게 적용되는지를 결정하는 방식이다. CSS를 렌더링하는 도구(ex. 브라우저)는 다음과 같은 방식을 통해 모든 요소의 모든 속성값을 어떻게 적용할지 결정한다.

1. 해당 요소를 선택하는 모든 선택자의 CSS 블록의 규칙들을 찾는다.
2. !important 속성을 가진 규칙과 아닌 규칙을 분리한다. !important가 붙은 속성이 우선이다.
3. 각각의 분리된 속성들에서 author, user, user-agent(브라우저 등) 규칙을 분리한다. author 규칙이 우선이다.
4. 

# 참고

https://poiemaweb.com/css3-inheritance-cascading

https://stackoverflow.com/questions/6749569/css-which-takes-precedence-inline-or-the-class